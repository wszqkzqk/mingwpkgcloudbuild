From 00e3fdce7c38c28e8ecffe569b23edd874a07b10 Mon Sep 17 00:00:00 2001
From: wszqkzqk <wszqkzqk@qq.com>
Date: Fri, 4 Nov 2022 15:41:40 +0800
Subject: [PATCH 1/8] add some functions close #44

---
 gee/functions.vala | 37 +++++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/gee/functions.vala b/gee/functions.vala
index c391c5f..1058ff0 100644
--- a/gee/functions.vala
+++ b/gee/functions.vala
@@ -56,6 +56,14 @@ namespace Gee {
 					else
 						return str_equal ((string) a, (string) b);
 				};
+			} else if (t == Type.CHAR || t == Type.UCHAR
+			|| t == Type.INT || t == Type.UINT
+			|| t == Type.INT64 || t == Type.UINT64
+			|| t == Type.LONG || t == Type.ULONG
+			|| t == Type.DOUBLE || t == Type.FLOAT) {
+				return (a, b) => {
+					return a == b;
+				}
 			} else if (t.is_a (typeof (Hashable))) {
 				return (a, b) => {
 					if (a == b)
@@ -93,6 +101,18 @@ namespace Gee {
 					else
 						return str_hash ((string) a);
 				};
+			} else if (t == Type.CHAR || t == Type.UCHAR || t == Type.INT || t == Type.UINT) {
+				return (a) => {
+					return int_hash (a);
+				}
+			} else if (t == Type.INT64 || t == Type.UINT64 || t == Type.LONG || t == Type.ULONG) {
+				return (a) => {
+					return int64_hash (a);
+				}
+			} else if (t == Type.DOUBLE || t == Type.FLOAT) {
+				return (a) => {
+					return double_hash (a);
+				}
 			} else if (t.is_a (typeof (Hashable))) {
 				return (a) => {
 					if (a == null)
@@ -124,6 +144,23 @@ namespace Gee {
 					else
 						return strcmp((string) a, (string) b);
 				};
+			} else if (t == Type.CHAR || t == Type.UCHAR
+			|| t == Type.INT || t == Type.UINT
+			|| t == Type.INT64 || t == Type.UINT64
+			|| t == Type.LONG || t == Type.ULONG
+			|| t == Type.DOUBLE || t == Type.FLOAT) {
+				return (a, b) => {
+					if (a == b)
+						return 0;
+					else if (a == null)
+						return -1;
+					else if (b == null)
+						return 1;
+					else if (a > b)
+						return 1;
+					else
+						return -1;
+				}
 			} else if (t.is_a (typeof (Comparable))) {
 				return (a, b) => {
 					if (a == b)
-- 
2.38.1.windows.1


From 079c2f53e5063af35b0855ec169f3dad6f0d26a2 Mon Sep 17 00:00:00 2001
From: wszqkzqk <wszqkzqk@qq.com>
Date: Fri, 4 Nov 2022 15:50:13 +0800
Subject: [PATCH 2/8] Adaptation for older versions of Vala

---
 gee/functions.vala | 12 ++++--------
 1 file changed, 4 insertions(+), 8 deletions(-)

diff --git a/gee/functions.vala b/gee/functions.vala
index 1058ff0..8d4978d 100644
--- a/gee/functions.vala
+++ b/gee/functions.vala
@@ -101,17 +101,13 @@ namespace Gee {
 					else
 						return str_hash ((string) a);
 				};
-			} else if (t == Type.CHAR || t == Type.UCHAR || t == Type.INT || t == Type.UINT) {
+			} else if (t == Type.CHAR || t == Type.UCHAR || t == Type.INT || t == Type.UINT || t == Type.FLOAT) {
 				return (a) => {
-					return int_hash (a);
+					return int_hash (a); // `GLib.int_hash` can be used for all 32-bit data
 				}
-			} else if (t == Type.INT64 || t == Type.UINT64 || t == Type.LONG || t == Type.ULONG) {
+			} else if (t == Type.INT64 || t == Type.UINT64 || t == Type.LONG || t == Type.ULONG || t == Type.DOUBLE) {
 				return (a) => {
-					return int64_hash (a);
-				}
-			} else if (t == Type.DOUBLE || t == Type.FLOAT) {
-				return (a) => {
-					return double_hash (a);
+					return int64_hash (a); // `GLib.int64_hash` can be used for all 64-bit data
 				}
 			} else if (t.is_a (typeof (Hashable))) {
 				return (a) => {
-- 
2.38.1.windows.1


From 36cb9cae85042668c93ec6e0b2a662d665f966f9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=98=9F=E5=A4=96=E4=B9=8B=E7=A5=9E?= <wszqkzqk@qq.com>
Date: Fri, 4 Nov 2022 17:59:05 +0800
Subject: [PATCH 3/8] minor optimization

---
 gee/functions.vala | 12 ++++--------
 1 file changed, 4 insertions(+), 8 deletions(-)

diff --git a/gee/functions.vala b/gee/functions.vala
index 8d4978d..798f609 100644
--- a/gee/functions.vala
+++ b/gee/functions.vala
@@ -82,7 +82,7 @@ namespace Gee {
 					else
 						return ((Comparable<Comparable>) a).compare_to ((Comparable) b) == 0;};
 			} else {
-				return (a, b) => {return direct_equal (a, b);};
+				return (EqualDataFunc<void*>) direct_equal;
 			}
 		}
 
@@ -102,13 +102,9 @@ namespace Gee {
 						return str_hash ((string) a);
 				};
 			} else if (t == Type.CHAR || t == Type.UCHAR || t == Type.INT || t == Type.UINT || t == Type.FLOAT) {
-				return (a) => {
-					return int_hash (a); // `GLib.int_hash` can be used for all 32-bit data
-				}
+				return (HashDataFunc<void*>) int_hash; // `GLib.int_hash` can be used for all 32-bit data
 			} else if (t == Type.INT64 || t == Type.UINT64 || t == Type.LONG || t == Type.ULONG || t == Type.DOUBLE) {
-				return (a) => {
-					return int64_hash (a); // `GLib.int64_hash` can be used for all 64-bit data
-				}
+				return (HashDataFunc<void*>) int64_hash; // `GLib.int64_hash` can be used for all 64-bit data
 			} else if (t.is_a (typeof (Hashable))) {
 				return (a) => {
 					if (a == null)
@@ -117,7 +113,7 @@ namespace Gee {
 						return ((Hashable) a).hash();
 				};
 			} else {
-				return (a) => {return direct_hash (a);};
+				return (HashDataFunc<void*>) direct_hash;
 			}
 		}
 
-- 
2.38.1.windows.1


From bca1f9472f7f15b8e06c6c3b7de12a108735047e Mon Sep 17 00:00:00 2001
From: wszqkzqk <wszqkzqk@qq.com>
Date: Fri, 4 Nov 2022 21:41:00 +0800
Subject: [PATCH 4/8] some fix

---
 gee/functions.vala | 24 ++++++++++++++++--------
 1 file changed, 16 insertions(+), 8 deletions(-)

diff --git a/gee/functions.vala b/gee/functions.vala
index 798f609..6301102 100644
--- a/gee/functions.vala
+++ b/gee/functions.vala
@@ -63,7 +63,7 @@ namespace Gee {
 			|| t == Type.DOUBLE || t == Type.FLOAT) {
 				return (a, b) => {
 					return a == b;
-				}
+				};
 			} else if (t.is_a (typeof (Hashable))) {
 				return (a, b) => {
 					if (a == b)
@@ -82,7 +82,7 @@ namespace Gee {
 					else
 						return ((Comparable<Comparable>) a).compare_to ((Comparable) b) == 0;};
 			} else {
-				return (EqualDataFunc<void*>) direct_equal;
+				return (a, b) => {return direct_equal (a, b);};
 			}
 		}
 
@@ -101,10 +101,18 @@ namespace Gee {
 					else
 						return str_hash ((string) a);
 				};
-			} else if (t == Type.CHAR || t == Type.UCHAR || t == Type.INT || t == Type.UINT || t == Type.FLOAT) {
-				return (HashDataFunc<void*>) int_hash; // `GLib.int_hash` can be used for all 32-bit data
-			} else if (t == Type.INT64 || t == Type.UINT64 || t == Type.LONG || t == Type.ULONG || t == Type.DOUBLE) {
-				return (HashDataFunc<void*>) int64_hash; // `GLib.int64_hash` can be used for all 64-bit data
+			} else if (t == Type.CHAR || t == Type.UCHAR || t == Type.INT || t == Type.UINT) {
+				return (a) => {
+					return int_hash (*(int*) a);
+				};
+			} else if (t == Type.INT64 || t == Type.UINT64 || t == Type.LONG || t == Type.ULONG) {
+				return (a) => {
+					return int64_hash (*(int64*) a);
+				};
+			} else if (t == Type.DOUBLE || t == Type.FLOAT) {
+				return (a) => {
+					return double_hash (*(double*) a);
+				};
 			} else if (t.is_a (typeof (Hashable))) {
 				return (a) => {
 					if (a == null)
@@ -113,7 +121,7 @@ namespace Gee {
 						return ((Hashable) a).hash();
 				};
 			} else {
-				return (HashDataFunc<void*>) direct_hash;
+				return (a) => {return direct_hash (a);};
 			}
 		}
 
@@ -152,7 +160,7 @@ namespace Gee {
 						return 1;
 					else
 						return -1;
-				}
+				};
 			} else if (t.is_a (typeof (Comparable))) {
 				return (a, b) => {
 					if (a == b)
-- 
2.38.1.windows.1


From 5a3d1b9457d7d4a1a725b227e6bc9ffb24d1a40b Mon Sep 17 00:00:00 2001
From: wszqkzqk <wszqkzqk@qq.com>
Date: Fri, 4 Nov 2022 22:51:35 +0800
Subject: [PATCH 5/8] Use pointer to fix

---
 gee/functions.vala | 54 ++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 45 insertions(+), 9 deletions(-)

diff --git a/gee/functions.vala b/gee/functions.vala
index 6301102..22fa479 100644
--- a/gee/functions.vala
+++ b/gee/functions.vala
@@ -62,7 +62,8 @@ namespace Gee {
 			|| t == Type.LONG || t == Type.ULONG
 			|| t == Type.DOUBLE || t == Type.FLOAT) {
 				return (a, b) => {
-					return a == b;
+					// Equality of binary content expressed in uint64 is equivalent to numerical equality
+					return *(uint64*) a == *(uint64*) b;
 				};
 			} else if (t.is_a (typeof (Hashable))) {
 				return (a, b) => {
@@ -144,20 +145,55 @@ namespace Gee {
 					else
 						return strcmp((string) a, (string) b);
 				};
-			} else if (t == Type.CHAR || t == Type.UCHAR
-			|| t == Type.INT || t == Type.UINT
-			|| t == Type.INT64 || t == Type.UINT64
-			|| t == Type.LONG || t == Type.ULONG
-			|| t == Type.DOUBLE || t == Type.FLOAT) {
+			} else if (t == Type.CHAR || t == Type.INT || t == Type.LONG || t == Type.INT64) {
 				return (a, b) => {
-					if (a == b)
+					if (a == null)
+						return b == null ? 0 : -1;
+					else if (b == null)
+						return 1;
+					else if (*(int64*) a > *(int64*) b)
+						return 1;
+					else if (*(int64*) a == *(int64*) b)
 						return 0;
-					else if (a == null)
+					else
+						return -1;
+				};
+			} else if (t == Type.UCHAR || t == Type.UINT || t == Type.ULONG || t == Type.UINT64) {
+				return (a, b) => {
+					if (a == null)
+						return b == null ? 0 : -1;
+					else if (b == null)
+						return 1;
+					else if (*(uint64*) a > *(uint64*) b)
+						return 1;
+					else if (*(uint64*) a == *(uint64*) b)
+						return 0;
+					else
 						return -1;
+				};
+			} else if (t == Type.DOUBLE) {
+				return (a, b) => {
+					if (a == null)
+						return b == null ? 0 : -1;
 					else if (b == null)
 						return 1;
-					else if (a > b)
+					else if (*(double*) a > *(double*) b)
 						return 1;
+					else if (*(double*) a == *(double*) b)
+						return 0;
+					else
+						return -1;
+				};
+			} else if (t == Type.FLOAT) {
+				return (a, b) => {
+					if (a == null)
+						return b == null ? 0 : -1;
+					else if (b == null)
+						return 1;
+					else if (*(float*) a > *(float*) b)
+						return 1;
+					else if (*(float*) a == *(float*) b)
+						return 0;
 					else
 						return -1;
 				};
-- 
2.38.1.windows.1


From abd1b57c1c884ed5ee768d1358a38b8408bc17f2 Mon Sep 17 00:00:00 2001
From: wszqkzqk <wszqkzqk@qq.com>
Date: Sat, 5 Nov 2022 00:03:20 +0800
Subject: [PATCH 6/8] use switch-case statement to simplify the code

---
 gee/functions.vala | 157 ++++++++++++++++++++++++++-------------------
 1 file changed, 92 insertions(+), 65 deletions(-)

diff --git a/gee/functions.vala b/gee/functions.vala
index 22fa479..d1e5731 100644
--- a/gee/functions.vala
+++ b/gee/functions.vala
@@ -47,7 +47,8 @@ namespace Gee {
 		 * @return the equality testing function corresponding to the given type.
 		 */
 		public static EqualDataFunc<void*> get_equal_func_for (Type t) {
-			if (t == typeof (string)) {
+			switch (t) {
+			case Type.STRING:
 				return (a, b) => {
 					if (a == b)
 						return true;
@@ -56,34 +57,41 @@ namespace Gee {
 					else
 						return str_equal ((string) a, (string) b);
 				};
-			} else if (t == Type.CHAR || t == Type.UCHAR
-			|| t == Type.INT || t == Type.UINT
-			|| t == Type.INT64 || t == Type.UINT64
-			|| t == Type.LONG || t == Type.ULONG
-			|| t == Type.DOUBLE || t == Type.FLOAT) {
+			case Type.CHAR:
+			case Type.UCHAR:
+			case Type.INT:
+			case Type.UINT:
+			case Type.INT64:
+			case Type.UINT64:
+			case Type.LONG:
+			case Type.ULONG:
+			case Type.DOUBLE:
+			case Type.FLOAT:
 				return (a, b) => {
 					// Equality of binary content expressed in uint64 is equivalent to numerical equality
 					return *(uint64*) a == *(uint64*) b;
 				};
-			} else if (t.is_a (typeof (Hashable))) {
-				return (a, b) => {
-					if (a == b)
-						return true;
-					else if (a == null || b == null)
-						return false;
-					else
-						return ((Hashable<Hashable>) a).equal_to ((Hashable) b);
-				};
-			} else if (t.is_a (typeof (Comparable))) {
-				return (a, b) => {					
-					if (a == b)
-						return true;
-					else if (a == null || b == null)
-						return false;
-					else
-						return ((Comparable<Comparable>) a).compare_to ((Comparable) b) == 0;};
-			} else {
-				return (a, b) => {return direct_equal (a, b);};
+			default:
+				if (t.is_a (typeof (Hashable))) {
+					return (a, b) => {
+						if (a == b)
+							return true;
+						else if (a == null || b == null)
+							return false;
+						else
+							return ((Hashable<Hashable>) a).equal_to ((Hashable) b);
+					};
+				} else if (t.is_a (typeof (Comparable))) {
+					return (a, b) => {					
+						if (a == b)
+							return true;
+						else if (a == null || b == null)
+							return false;
+						else
+							return ((Comparable<Comparable>) a).compare_to ((Comparable) b) == 0;};
+				} else {
+					return (a, b) => {return direct_equal (a, b);};
+				}
 			}
 		}
 
@@ -95,34 +103,44 @@ namespace Gee {
 		 * @return the hash function corresponding to the given type.
 		 */
 		public static HashDataFunc<void*> get_hash_func_for (Type t) {
-			if (t == typeof (string)) {
+			switch (t) {
+			case Type.STRING:
 				return (a) => {
 					if (a == null)
 						return (uint)0xdeadbeef;
 					else
 						return str_hash ((string) a);
 				};
-			} else if (t == Type.CHAR || t == Type.UCHAR || t == Type.INT || t == Type.UINT) {
+			case Type.CHAR:
+			case Type.UCHAR:
+			case Type.INT:
+			case Type.UINT:
 				return (a) => {
 					return int_hash (*(int*) a);
 				};
-			} else if (t == Type.INT64 || t == Type.UINT64 || t == Type.LONG || t == Type.ULONG) {
+			case Type.INT64:
+			case Type.UINT64:
+			case Type.LONG:
+			case Type.ULONG:
 				return (a) => {
 					return int64_hash (*(int64*) a);
 				};
-			} else if (t == Type.DOUBLE || t == Type.FLOAT) {
+			case Type.DOUBLE:
+			case Type.FLOAT:
 				return (a) => {
 					return double_hash (*(double*) a);
 				};
-			} else if (t.is_a (typeof (Hashable))) {
-				return (a) => {
-					if (a == null)
-						return (uint)0xdeadbeef;
-					else
-						return ((Hashable) a).hash();
-				};
-			} else {
-				return (a) => {return direct_hash (a);};
+			default:
+				if (t.is_a (typeof (Hashable))) {
+					return (a) => {
+						if (a == null)
+							return (uint)0xdeadbeef;
+						else
+							return ((Hashable) a).hash();
+					};
+				} else {
+					return (a) => {return direct_hash (a);};
+				}
 			}
 		}
 
@@ -134,7 +152,8 @@ namespace Gee {
 		 * @return the comparator function corresponding to the given type.
 		 */
 		public static CompareDataFunc<void*> get_compare_func_for (Type t) {
-			if (t == typeof (string)) {
+			switch (t) {
+			case Type.STRING:
 				return (a, b) => {
 					if (a == b)
 						return 0;
@@ -145,7 +164,10 @@ namespace Gee {
 					else
 						return strcmp((string) a, (string) b);
 				};
-			} else if (t == Type.CHAR || t == Type.INT || t == Type.LONG || t == Type.INT64) {
+			case Type.CHAR:
+			case Type.INT:
+			case Type.LONG:
+			case Type.INT64:
 				return (a, b) => {
 					if (a == null)
 						return b == null ? 0 : -1;
@@ -158,7 +180,10 @@ namespace Gee {
 					else
 						return -1;
 				};
-			} else if (t == Type.UCHAR || t == Type.UINT || t == Type.ULONG || t == Type.UINT64) {
+			case Type.UCHAR:
+			case Type.UINT:
+			case Type.ULONG:
+			case Type.UINT64:
 				return (a, b) => {
 					if (a == null)
 						return b == null ? 0 : -1;
@@ -171,7 +196,7 @@ namespace Gee {
 					else
 						return -1;
 				};
-			} else if (t == Type.DOUBLE) {
+			case Type.DOUBLE:
 				return (a, b) => {
 					if (a == null)
 						return b == null ? 0 : -1;
@@ -184,7 +209,7 @@ namespace Gee {
 					else
 						return -1;
 				};
-			} else if (t == Type.FLOAT) {
+			case Type.FLOAT:
 				return (a, b) => {
 					if (a == null)
 						return b == null ? 0 : -1;
@@ -197,28 +222,30 @@ namespace Gee {
 					else
 						return -1;
 				};
-			} else if (t.is_a (typeof (Comparable))) {
-				return (a, b) => {
-					if (a == b)
-						return 0;
-					else if (a == null)
-						return -1;
-					else if (b == null)
-						return 1;
-					else
-						return ((Comparable<Comparable>) a).compare_to ((Comparable) b);
-				};
-			} else {
-				return (_val1, _val2) => {
-					long val1 = (long)_val1, val2 = (long)_val2;
-					if (val1 > val2) {
-						return 1;
-					} else if (val1 == val2) {
-						return 0;
-					} else {
-						return -1;
-					}
-				};
+			default:
+				if (t.is_a (typeof (Comparable))) {
+					return (a, b) => {
+						if (a == b)
+							return 0;
+						else if (a == null)
+							return -1;
+						else if (b == null)
+							return 1;
+						else
+							return ((Comparable<Comparable>) a).compare_to ((Comparable) b);
+					};
+				} else {
+					return (_val1, _val2) => {
+						long val1 = (long)_val1, val2 = (long)_val2;
+						if (val1 > val2) {
+							return 1;
+						} else if (val1 == val2) {
+							return 0;
+						} else {
+							return -1;
+						}
+					};
+				}
 			}
 		}
 
-- 
2.38.1.windows.1


From db988532d30ed4f3eed40887479cf0c939f48579 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=98=9F=E5=A4=96=E4=B9=8B=E7=A5=9E?= <wszqkzqk@qq.com>
Date: Sat, 5 Nov 2022 00:15:36 +0800
Subject: [PATCH 7/8] set hash value for null

---
 gee/functions.vala | 15 ++++++++++++---
 1 file changed, 12 insertions(+), 3 deletions(-)

diff --git a/gee/functions.vala b/gee/functions.vala
index d1e5731..7fdbb85 100644
--- a/gee/functions.vala
+++ b/gee/functions.vala
@@ -116,19 +116,28 @@ namespace Gee {
 			case Type.INT:
 			case Type.UINT:
 				return (a) => {
-					return int_hash (*(int*) a);
+					if (a == null)
+						return (uint)0xdeadbeef;
+					else
+						return int_hash (*(int*) a);
 				};
 			case Type.INT64:
 			case Type.UINT64:
 			case Type.LONG:
 			case Type.ULONG:
 				return (a) => {
-					return int64_hash (*(int64*) a);
+					if (a == null)
+						return (uint)0xdeadbeef;
+					else
+						return int64_hash (*(int64*) a);
 				};
 			case Type.DOUBLE:
 			case Type.FLOAT:
 				return (a) => {
-					return double_hash (*(double*) a);
+					if (a == null)
+						return (uint)0xdeadbeef;
+					else
+						return double_hash (*(double*) a);
 				};
 			default:
 				if (t.is_a (typeof (Hashable))) {
-- 
2.38.1.windows.1


From ddba4d0544d5f4602d35928ba4f6906de333e358 Mon Sep 17 00:00:00 2001
From: wszqkzqk <wszqkzqk@qq.com>
Date: Sat, 5 Nov 2022 17:05:17 +0800
Subject: [PATCH 8/8] fix for types shorter than 64 bits

---
 gee/functions.vala | 131 +++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 120 insertions(+), 11 deletions(-)

diff --git a/gee/functions.vala b/gee/functions.vala
index 7fdbb85..ca35c1c 100644
--- a/gee/functions.vala
+++ b/gee/functions.vala
@@ -59,18 +59,29 @@ namespace Gee {
 				};
 			case Type.CHAR:
 			case Type.UCHAR:
+				return (a, b) => {
+					// Equality of binary content expressed in uchar is equivalent to numerical equality
+					return *(uchar*) a == *(uchar*) b;
+				};
 			case Type.INT:
 			case Type.UINT:
+			case Type.FLOAT:
+				return (a, b) => {
+					// Equality of binary content expressed in uint is equivalent to numerical equality
+					return *(uint*) a == *(uint*) b;
+				};
 			case Type.INT64:
 			case Type.UINT64:
-			case Type.LONG:
-			case Type.ULONG:
 			case Type.DOUBLE:
-			case Type.FLOAT:
 				return (a, b) => {
 					// Equality of binary content expressed in uint64 is equivalent to numerical equality
 					return *(uint64*) a == *(uint64*) b;
 				};
+			case Type.LONG:
+			case Type.ULONG:
+				return (a, b) => {
+					return *(ulong*) a == *(ulong*) b;
+				};
 			default:
 				if (t.is_a (typeof (Hashable))) {
 					return (a, b) => {
@@ -107,43 +118,69 @@ namespace Gee {
 			case Type.STRING:
 				return (a) => {
 					if (a == null)
-						return (uint)0xdeadbeef;
+						return (uint) 0xdeadbeef;
 					else
 						return str_hash ((string) a);
 				};
 			case Type.CHAR:
 			case Type.UCHAR:
+				return (a) => {
+					if (a == null)
+						return (uint) 0xdeadbeef;
+					else
+						return int_hash ((int) *(char*) a);
+				};
 			case Type.INT:
 			case Type.UINT:
 				return (a) => {
 					if (a == null)
-						return (uint)0xdeadbeef;
+						return (uint) 0xdeadbeef;
 					else
 						return int_hash (*(int*) a);
 				};
 			case Type.INT64:
 			case Type.UINT64:
-			case Type.LONG:
-			case Type.ULONG:
 				return (a) => {
 					if (a == null)
-						return (uint)0xdeadbeef;
+						return (uint) 0xdeadbeef;
 					else
 						return int64_hash (*(int64*) a);
 				};
 			case Type.DOUBLE:
-			case Type.FLOAT:
 				return (a) => {
 					if (a == null)
-						return (uint)0xdeadbeef;
+						return (uint) 0xdeadbeef;
 					else
 						return double_hash (*(double*) a);
 				};
+			case Type.FLOAT:
+				return (a) => {
+					if (a == null)
+						return (uint) 0xdeadbeef;
+					else
+						return double_hash ((double) *(float*) a);
+				};
+			case Type.LONG:
+			case Type.ULONG:
+				if (ulong.MAX > uint32.MAX)
+					return (a) => {
+						if (a == null)
+							return (uint) 0xdeadbeef;
+						else
+							return int64_hash (*(int64*) a);
+					};
+				else
+					return (a) => {
+						if (a == null)
+							return (uint) 0xdeadbeef;
+						else
+							return int_hash (*(int*) a);
+					};
 			default:
 				if (t.is_a (typeof (Hashable))) {
 					return (a) => {
 						if (a == null)
-							return (uint)0xdeadbeef;
+							return (uint) 0xdeadbeef;
 						else
 							return ((Hashable) a).hash();
 					};
@@ -174,8 +211,44 @@ namespace Gee {
 						return strcmp((string) a, (string) b);
 				};
 			case Type.CHAR:
+				return (a, b) => {
+					if (a == null)
+						return b == null ? 0 : -1;
+					else if (b == null)
+						return 1;
+					else if (*(char*) a > *(char*) b)
+						return 1;
+					else if (*(char*) a == *(char*) b)
+						return 0;
+					else
+						return -1;
+				};
 			case Type.INT:
+				return (a, b) => {
+					if (a == null)
+						return b == null ? 0 : -1;
+					else if (b == null)
+						return 1;
+					else if (*(int*) a > *(int*) b)
+						return 1;
+					else if (*(int*) a == *(int*) b)
+						return 0;
+					else
+						return -1;
+				};
 			case Type.LONG:
+				return (a, b) => {
+					if (a == null)
+						return b == null ? 0 : -1;
+					else if (b == null)
+						return 1;
+					else if (*(long*) a > *(long*) b)
+						return 1;
+					else if (*(long*) a == *(long*) b)
+						return 0;
+					else
+						return -1;
+				};
 			case Type.INT64:
 				return (a, b) => {
 					if (a == null)
@@ -190,8 +263,44 @@ namespace Gee {
 						return -1;
 				};
 			case Type.UCHAR:
+				return (a, b) => {
+					if (a == null)
+						return b == null ? 0 : -1;
+					else if (b == null)
+						return 1;
+					else if (*(uchar*) a > *(uchar*) b)
+						return 1;
+					else if (*(uchar*) a == *(uchar*) b)
+						return 0;
+					else
+						return -1;
+				};
 			case Type.UINT:
+				return (a, b) => {
+					if (a == null)
+						return b == null ? 0 : -1;
+					else if (b == null)
+						return 1;
+					else if (*(uint*) a > *(uint*) b)
+						return 1;
+					else if (*(uint*) a == *(uint*) b)
+						return 0;
+					else
+						return -1;
+				};
 			case Type.ULONG:
+				return (a, b) => {
+					if (a == null)
+						return b == null ? 0 : -1;
+					else if (b == null)
+						return 1;
+					else if (*(ulong*) a > *(ulong*) b)
+						return 1;
+					else if (*(ulong*) a == *(ulong*) b)
+						return 0;
+					else
+						return -1;
+				};
 			case Type.UINT64:
 				return (a, b) => {
 					if (a == null)
-- 
2.38.1.windows.1

